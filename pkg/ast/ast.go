//go:generate go run generate-ast-nodes.go

/*
the ast package hold the ast nodes for `temp-lang` for the ast that will be
generated by a parser, and evaluated as a program
*/
package ast

import (
	"fmt"
	"strings"
)

type Node interface {
	Literal() any
	Lexeme() string
	String() string
}

type Stmt interface {
	Node
	StmtNode() // Dummy method to make go treat Expr and Stmt differently
}

type Expr interface {
	Node
	ExprNode() // Dummy method to make go treat Expr and Stmt differently
}

type Program struct {
	Statements []Stmt
}

func (p *Program) TokenLiteral() string {
	if len(p.Statements) > 0 {
		return p.Statements[0].Lexeme()
	} else {
		return ""
	}
}

func (p *Program) String() string {
	var str strings.Builder

	for _, stmt := range p.Statements {
		str.WriteString(stmt.String())
	}

	return str.String()
}

// / =========
func (l *LetStmt) String() string {
	var str strings.Builder

	// TODO: update String when let is is fully implemented
	fmt.Fprintf(&str, "let %s = %s;\n", l.Name.String(), l.Value.String())

	return str.String()
}

func (i *IdentifierExpr) String() string {
	var str strings.Builder

	fmt.Fprintf(&str, "%s", i.Value)

	return str.String()
}

func (p *PrefixExpr) String() string {
	var s strings.Builder

	s.WriteString("(")
	s.WriteString(p.Lexeme() + p.Operand.String())
	s.WriteString(")")

	return s.String()
}

func (n *NumberLiteralExpr) String() string {
	return n.Lexeme()
}

func (s *StringLiteralExpr) String() string {
	return s.Lexeme()
}

func (s *BooleanLiteralExpr) String() string {
	return s.Lexeme()
}
